lab 6:
1:
PRESERVE8
	THUMB ; Marks the THUMB mode of operation
;Data variables are declared in DATA AREA;
	AREA const_data , DATA, READONLY
; Initialing some constants
SYSCTL_RCGCGPIO_R EQU 0x400FE608
GPIO_PORTF_AFSEL_R EQU 0x40025420
GPIO_PORTF_DIR_R EQU 0x40025400
GPIO_PORTF_DEN_R EQU 0x4002551C
GPIO_PORTF_DATA_R EQU 0x400253FC
DELAY EQU 200000
;The user code ( program) is placed in CODE AREA;
	AREA |.text| , CODE, READONLY, ALIGN=2
	ENTRY ; ENTRY marks the starting point of the code execution
	EXPORT __main
__main
; User Code starts from the next line
; Enable clock for PORT F
	LDR R1 , =SYSCTL_RCGCGPIO_R
	LDR R0 , [R1]
	ORR R0 ,R0, #0x20
	STR R0 , [R1]
	NOP ; No operations for 3 cycles
	NOP
	NOP
	Nop
	Nop
	Nop
; Set the direction for PORT F
	LDR R1 , =GPIO_PORTF_DIR_R
	LDR R0 , [R1]
	ORR R0 , #0x04
	STR R0 , [R1]
 ; Digital enable for PORT F
	LDR R1 , =GPIO_PORTF_DEN_R
	LDR R0 , [R1]
	ORR R0 , #0x04
	STR R0 , [R1]
; Infinite loop LED flash
LED_flash
; Set the data for PORT F to turn LED on
	LDR R1 , =GPIO_PORTF_DATA_R
	LDR R0 , [R1]
	ORR R0 , R0 , #0x04
	STR R0 , [R1]
; Delay loop
	LDR R5 , =DELAY
delay1
	SUBS R5,#1
	BNE delay1
; Set the data for PORT F to turn LED off
	LDR R1 , =GPIO_PORTF_DATA_R
	LDR R0 , [R1]
	AND R0 , R0 , #0xFB
	STR R0 , [R1]
; Delay loop
	LDR R5 , =DELAY
delay2
	SUBS R5,#1
	BNE delay2
	B LED_flash
	ALIGN
	END ; End of the program , matched with ENTRY keyword
-------------------------------------------------
2:
#define SYSCTL_RCGCGPIO_R (*((volatile unsigned long *)0x400FE608))
#define GPIO_PORTF_DATA_R (*((volatile unsigned long *)0x400253FC))
#define GPIO_PORTF_DIR_R (*((volatile unsigned long *)0x40025400))
#define GPIO_PORTF_DEN_R (*((volatile unsigned long *)0x4002551C))
#define DELAY 600000


void delay( volatile unsigned long ulLoop ){
	
		// Delay for a bit.
		for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
			{
			for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
			{}
			}
	
}

int main ( void )
{
	volatile unsigned long ulLoop ;
	// Enable the GPIO port that is used for the onboard LED.
	SYSCTL_RCGCGPIO_R = 0x20;

	// Do a dummy read to insert a few cycles after enabling the peripheral.
	ulLoop = SYSCTL_RCGCGPIO_R;
	
	// Enable the GPIO pin for the LED (PF3). Set the direction as output and enable the GPIO pin for digital
	GPIO_PORTF_DIR_R = 0x04;
	GPIO_PORTF_DATA_R = 0x04;
	GPIO_PORTF_DEN_R = 0x04;
	
	
	
	// Loop for ever.
	while (1) {

		// Toggle blue LED on.
		GPIO_PORTF_DATA_R |= 0x04;

		delay(ulLoop);
		
        // Toggle blue LED off.
		GPIO_PORTF_DATA_R &= ~(0x04);

        delay(ulLoop);
		
	}
	
******************************************************************************************
lab7
1:
#include "TM4C123GH6PM.h"
#define DELAY 200000
#define SYSCTL_RCGCGPIO_R (*((volatile unsigned long *)0x400FE608))
int main(void)
{
	volatile unsigned long ulLoop ;
	SYSCTL_RCGCGPIO_R = 0x08;
	ulLoop = SYSCTL_RCGCGPIO_R;
	
 unsigned int state;
 SYSCTL->RCGCGPIO |= 0x20; /* enable clock to GPIOF */
 GPIOF->LOCK = 0x4C4F434B; // unlockGPIOCR register
 GPIOF->CR = 0x01; // Enable GPIOPUR register enable to commit
 GPIOF->PUR |= 0x10; // Enable Pull Up resistor PF4
 GPIOF->DIR |= 0x08; //set PF1 as an output and PF4 as an input pin
 GPIOF->DEN |= 0x18; // Enable PF1 and PF4 as a digital GPIO pins
	
 while(1)
 {
	 
 state = GPIOF->DATA & 0x10;
	 for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
 {
 }
}

	 if(!state && GPIOF ->DATA == 0X08){
      GPIOF->DATA= (state>>1);
	 }
	 else if(!state && GPIOF ->DATA == 0X00) 
		 GPIOF->DATA= (~state>>1);
 }
}
------------------------------
2:
*PORTF PF0 and PF4 fall edge interrupt example*/
/*This GPIO interrupt example code controls green LED with switches SW1 and SW2 external interrupts */
#include "TM4C123.h" // Device header
#define SYSCTL_RCGCGPIO_R (*((volatile unsigned long *)0x400FE608))
#define DELAY 20000000
int f=0;
int i=0;
int main(void)
{
SYSCTL->RCGCGPIO |= (1<<5); /* Set bit5 of RCGCGPIO to enable clock to PORTF*/
/* PORTF0 has special function, need to unlock to modify */
GPIOF->LOCK = 0x4C4F434B; /* unlock commit register */
GPIOF->CR = 0x01; /* make PORTF0 configurable */
GPIOF->LOCK = 0; /* lock commit register */
	
	
/*Initialize PF3 as a digital output, PF0 and PF4 as digital input pins */
GPIOF->DIR &= ~(1<<4)|~(1<<0); /* Set PF4 and PF0 as a digital input pins */
GPIOF->DIR |= (1<<3)|(1<<2)|(1<<1); /* Set PF3 as digital output to control green LED */
GPIOF->DEN |= (1<<4)|(1<<3)|(1<<0)|(1<<2)|(1<<1); /* make PORTF4-0 digital pins */
GPIOF->PUR |= (1<<4)|(1<<0); /* enable pull up for PORTF4, 0 */
	
	
/* configure PORTF4, 0 for falling edge trigger interrupt */
GPIOF->IS &= ~(1<<4)|~(1<<0); /* make bit 4, 0 edge sensitive */
GPIOF->IBE &=~(1<<4)|~(1<<0); /* trigger is controlled by IEV */
GPIOF->IEV &= ~(1<<4)|~(1<<0); /* falling edge trigger */
GPIOF->ICR |= (1<<4)|(1<<0); /* clear any prior interrupt */
GPIOF->IM |= (1<<4)|(1<<0); /* unmask interrupt */
	
	
/* enable interrupt in NVIC and set priority to 3 */
NVIC->IP[30] = 3 << 5; /* set interrupt priority to 3 */
NVIC->ISER[0] |= (1<<30); /* enable IRQ30 (D30 of ISER[0]) */
while(1)
{
	if (f==0){
		GPIOF->DATA = (1<<1);
	}
	 for( i = 0; i < 2000000; i++);
// do nothing and wait for the interrupt to occur
}
}
/* SW1 is connected to PF4 pin, SW2 is connected to PF0. */
/* Both of them trigger PORTF falling edge interrupt */
void GPIOF_Handler(void)
{
volatile unsigned long ulLoop ;
ulLoop = SYSCTL_RCGCGPIO_R;
	
///////////////////////////////////////////////////////////////////////
if (GPIOF->MIS & 0x10) /* check if interrupt causes by PF4/SW1*/
{
	f=1;
GPIOF->DATA = (1<<3);
// Delay for a bit.
 for( i = 0; i < 2000000; i++);

// Delay for a bit.
GPIOF->ICR |= 0x01; /* clear the interrupt flag */
}
else if (GPIOF->MIS & 0x01) /* check if interrupt causes by PF0/SW2 */
{
 f=1;
 GPIOF->DATA = (1<<2);
 for( i = 0; i < 2000000; i++);
 
GPIOF->ICR |= 0x01; /* clear the interrupt flag */
}
}
---------------------------
3:
/*PORTF PF0 and PF4 fall edge interrupt example*/
/*This GPIO interrupt example code controls green LED with switches SW1 and SW2 external interrupts */
#include "TM4C123.h" // Device header
#define SYSCTL_RCGCGPIO_R (*((volatile unsigned long *)0x400FE608))
#define DELAY 2000000
int main(void)
{
SYSCTL->RCGCGPIO |= (1<<5); /* Set bit5 of RCGCGPIO to enable clock to PORTF*/
/* PORTF0 has special function, need to unlock to modify */
GPIOF->LOCK = 0x4C4F434B; /* unlock commit register */
GPIOF->CR = 0x01; /* make PORTF0 configurable */
GPIOF->LOCK = 0; /* lock commit register */
	
	
/*Initialize PF3 as a digital output, PF0 and PF4 as digital input pins */
GPIOF->DIR &= ~(1<<4)|~(1<<0); /* Set PF4 and PF0 as a digital input pins */
GPIOF->DIR |= (1<<3)|(1<<2)|(1<<1); /* Set PF3 as digital output to control green LED */
GPIOF->DEN |= (1<<4)|(1<<3)|(1<<0)|(1<<2)|(1<<1); /* make PORTF4-0 digital pins */
GPIOF->PUR |= (1<<4)|(1<<0); /* enable pull up for PORTF4, 0 */
	
	
/* configure PORTF4, 0 for falling edge trigger interrupt */
GPIOF->IS &= ~(1<<4)|~(1<<0); /* make bit 4, 0 edge sensitive */
GPIOF->IBE &=~(1<<4)|~(1<<0); /* trigger is controlled by IEV */
GPIOF->IEV &= ~(1<<4)|~(1<<0); /* falling edge trigger */
GPIOF->ICR |= (1<<4)|(1<<0); /* clear any prior interrupt */
GPIOF->IM |= (1<<4)|(1<<0); /* unmask interrupt */
	
	
/* enable interrupt in NVIC and set priority to 3 */
NVIC->IP[30] = 3 << 5; /* set interrupt priority to 3 */
NVIC->ISER[0] |= (1<<30); /* enable IRQ30 (D30 of ISER[0]) */
while(1)
{
// do nothing and wait for the interrupt to occur
}
}
/* SW1 is connected to PF4 pin, SW2 is connected to PF0. */
/* Both of them trigger PORTF falling edge interrupt */
void GPIOF_Handler(void)
{
volatile unsigned long ulLoop ;
ulLoop = SYSCTL_RCGCGPIO_R;
	
///////////////////////////////////////////////////////////////////////
if (GPIOF->MIS & 0x10) /* check if interrupt causes by PF4/SW1*/
{
GPIOF->DATA = (1<<3);
// Delay for a bit.
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
}
}
///////////////////////////
GPIOF->DATA = (1<<2);
// Delay for a bit.
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
}
} 
///////////
GPIOF->DATA = (1<<1);
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
}
} 
// Delay for a bit.
GPIOF->ICR |= 0x01; /* clear the interrupt flag */
}
else if (GPIOF->MIS & 0x01) /* check if interrupt causes by PF0/SW2 */
{
 GPIOF->DATA = (1<<1);
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
}
} 
 GPIOF->DATA = (1<<2);
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
for (ulLoop = 0; ulLoop < DELAY; ulLoop++)
{
}
} 
 GPIOF->DATA = (1<<3);
GPIOF->ICR |= 0x01; /* clear the interrupt flag */
}
}
******************************************************************
lab8:
1:
#include "TM4C123.h" // Device header file for Tiva Series Microcontroller
#define Green (1<<3) // PF2 pin of TM4C123 Tiva Launchpad, Green LED
void Time1A_halfsec_delay(void);
int main(void)
{
/*Initialize PF2 as a digital output pin */
 SYSCTL->RCGCGPIO |= 0x20; // turn on bus clock for GPIOF
 GPIOF->DIR |= Green; // set green pin as a digital output pin
 GPIOF->DEN |= Green; // Enable PF2 pin as a digital pin
 Time1A_halfsec_delay();
while(1)
{
// do nothing wait for the interrupt to occur
}
}
/* Timer1 subtimer A interrupt service routine */
TIMER1A_Handler()
{
 if(TIMER1->MIS & 0x1)
GPIOF->DATA ^= Green; /* toggle Green LED*/
TIMER1->ICR = 0x1; /* Timer1A timeout flag bit clears*/
}
void Time1A_halfsec_delay(void)
{
SYSCTL->RCGCTIMER |= (1<<1); /*enable clock Timer1 subtimer A in run mode */
TIMER1->CTL = 0; /* disable timer1 output */
TIMER1->CFG = 0x4; /*select 16-bit configuration option */
TIMER1->TAMR = 0x02; /*select periodic down counter mode of timer1 */
TIMER1->TAPR = 125-1; /* TimerA prescaler value */
TIMER1->TAILR = 64000-1 ; /* TimerA counter starting count down value */
TIMER1->ICR = 0x1; /* TimerA timeout flag bit clears*/
TIMER1->IMR |=(1<<0); /*enables TimerA time-out interrupt mask */
TIMER1->CTL |= 0x01; /* Enable TimerA module */
NVIC->ISER[0] |= (1<<21); /*enable IRQ21 */
}
----------------------------------
2:
#include "TM4C123.h" // Device header file for Tiva Series Microcontroller
#define RED (1<<1) // PF3 pin of TM4C123 Tiva Launchpad, Blue LED
void Time1A_1sec_delay(void);
int main(void)
{
/*Initialize PF3 as a digital output pin */
SYSCTL->RCGCGPIO |= 0x20; // turn on bus clock for GPIOF
GPIOF->DIR |= RED; // set blue pin as a digital output pin
GPIOF->DEN |= RED; // Enable PF2 pin as a digital pin
Time1A_1sec_delay();
while(1)
{
// do nothing wait for the interrupt to occur
}
}
/* Timer1 subtimer A interrupt service routine */

TIMER1A_Handler()
{
if(TIMER1->MIS & 0x1)
GPIOF->DATA ^= RED; /* toggle Blue LED*/
TIMER1->ICR = 0x1; /* Timer1A timeout flag bit clears*/
}

void Time1A_1sec_delay(void)
{
SYSCTL->RCGCTIMER |= (1<<1); /*enable clock Timer1 subtimer A in run mode */
TIMER1->CTL = 0; /* disable timer1 output */
TIMER1->CFG = 0x00; /*select 32-bit configuration option */
TIMER1->TAMR = 0x02; /*select periodic down counter mode of timer1 */
TIMER1->TAILR = 64000000-1 ; /* TimerA counter starting count down value */
TIMER1->ICR = 0x1; /* TimerA timeout flag bit clears*/
TIMER1->IMR |=(1<<0); /*enables TimerA time-out interrupt mask */
TIMER1->CTL |= 0x01; /* Enable TimerA module */
NVIC->ISER[0] |= (1<<21); /*enable IRQ21 */
}
----------------------
#include "TM4C123.h" // Device header file for Tiva Series Microcontroller
#define Red (1<<1) // PF1 pin of TM4C123 Tiva Launchpad, Red LED

void Time1A_halfsec_delay(void);
void TIMER1A_Handler(void);

int main(void)
{
    SYSCTL->RCGCGPIO |= 0x20; // turn on bus clock for GPIOF
    GPIOF->DIR |= Red; // set red pin as a digital output pin
    GPIOF->DEN |= Red; // Enable PF1 pin as a digital pin

    Time1A_halfsec_delay();

    while(1)
    {
        // do nothing wait for the interrupt to occur
    }
}

/* Timer1 subtimer A interrupt service routine */
void TIMER1A_Handler()
{
    if(TIMER1->MIS & 0x1)
    {
        GPIOF->DATA ^= Red; /* toggle Red LED*/
        TIMER1->ICR = 0x1; /* Timer1A timeout flag bit clears*/
    }
}

void Time1A_halfsec_delay(void)
{
    SYSCTL->RCGCTIMER |= (1<<1); /*enable clock Timer1 subtimer A in run mode */
    TIMER1->CTL = 0; /* disable timer1 output */
    TIMER1->CFG = 0x4; /*select 16-bit configuration option */
    TIMER1->TAMR = 0x02; /*select periodic down counter mode of timer1 */
    TIMER1->TAPR = 250-1; /* TimerA prescaler value */
    TIMER1->TAILR = 64000000-1 ; /* TimerA counter starting count down value */
    TIMER1->ICR = 0x1; /* TimerA timeout flag bit clears*/
    TIMER1->IMR |=(1<<0); /*enables TimerA time-out interrupt mask */
    TIMER1->CTL |= 0x01; /* Enable TimerA module */
    NVIC_EnableIRQ(TIMER1A_IRQn); /* Enable TIMER1A interrupt */
}
----------------------------------
#include "TM4C123.h" // Device header file for Tiva Series Microcontroller

#define LED_10s (1<<3) // PF3 pin of TM4C123, Onboard LED, flashes every 10s
#define LED_5s (1<<2)  // PF2 pin of TM4C123, External LED1, flashes every 5s
#define LED_1s (1<<1)  // PF1 pin of TM4C123, External LED2, flashes every 1s

// Timer1 Subtimer A interrupt service routine
void TIMER1A_Handler()
{
    if(TIMER1->MIS & 0x1)
    {
        GPIOF->DATA ^= LED_10s; /* toggle onboard LED*/
        TIMER1->ICR = 0x1; /* Timer1A timeout flag bit clears*/
    }
}

// Timer2 Subtimer A interrupt service routine
void TIMER2A_Handler()
{
    if(TIMER2->MIS & 0x1)
    {
        GPIOF->DATA ^= LED_5s; /* toggle External LED1*/
        TIMER2->ICR = 0x1; /* Timer2A timeout flag bit clears*/
    }
}

// Timer3 Subtimer A interrupt service routine
void TIMER3A_Handler()
{
    if(TIMER3->MIS & 0x1)
    {
        GPIOF->DATA ^= LED_1s; /* toggle External LED2*/
        TIMER3->ICR = 0x1; /* Timer3A timeout flag bit clears*/
    }
}

void Timer1A_10sec_delay(void)
{
    SYSCTL->RCGCTIMER |= (1<<1); /*enable clock Timer1 subtimer A in run mode */
    TIMER1->CTL = 0; /* disable timer1 output */
    TIMER1->CFG = 0x4; /*select 16-bit configuration option */
    TIMER1->TAMR = 0x02; /*select periodic down counter mode of timer1 */
    TIMER1->TAPR = 250-1; /* TimerA prescaler value */
    TIMER1->TAILR = 12800000-1 ; /* TimerA counter starting count down value */
    TIMER1->ICR = 0x1; /* TimerA timeout flag bit clears*/
    TIMER1->IMR |=(1<<0); /*enables TimerA time-out interrupt mask */
    TIMER1->CTL |= 0x01; /* Enable TimerA module */
    NVIC_EnableIRQ(TIMER1A_IRQn); /* Enable TIMER1A interrupt */
}
void Timer2A_5sec_delay(void)
{
    SYSCTL->RCGCTIMER |= (1<<2); /*enable clock Timer2 subtimer A in run mode */
    TIMER2->CTL = 0; /* disable timer2 output */
    TIMER2->CFG = 0x4; /*select 16-bit configuration option */
    TIMER2->TAMR = 0x02; /*select periodic down counter mode of timer2 */
    TIMER2->TAPR = 250-1; /* Timer2 prescaler value */
TIMER2->TAILR = 640000-1 ; /* Timer2 counter starting count down value */
TIMER2->ICR = 0x1; /* Timer2A timeout flag bit clears */
TIMER2->IMR |=(1<<0); /* enables Timer2A time-out interrupt mask */
TIMER2->CTL |= 0x01; /* Enable Timer2A module */
NVIC_EnableIRQ(TIMER2A_IRQn); /* Enable TIMER2A interrupt */

}

void Timer3A_1sec_delay(void)
{
SYSCTL->RCGCTIMER |= (1<<3); /*enable clock Timer3 subtimer A in run mode */
TIMER3->CTL = 0; /* disable timer3 output */
TIMER3->CFG = 0x4; /*select 16-bit configuration option */
TIMER3->TAMR = 0x02; //select periodic down counter mode of timer3
TIMER3->TAPR = 250-1; /* Timer3 prescaler value */
TIMER3->TAILR = 64000-1 ; /* Timer3 counter starting count down value */
TIMER3->ICR = 0x1; /* Timer3A timeout flag bit clears */
TIMER3->IMR |=(1<<0); /* enables Timer3A time-out interrupt mask */
TIMER3->CTL |= 0x01; /* Enable Timer3A module */
NVIC_EnableIRQ(TIMER3A_IRQn); /* Enable TIMER3A interrupt */
}

int main(void)
{
    // Initialize the onboard LED as an output
    SYSCTL->RCGCGPIO |= (1<<5);
    GPIOF->DIR |= LED_10s;
    GPIOF->DEN |= LED_10s;
    
    // Initialize the external LEDs as outputs
    SYSCTL->RCGCGPIO |= (1<<5);
    GPIOF->DIR |= LED_5s;
    GPIOF->DEN |= LED_5s;
    
    SYSCTL->RCGCGPIO |= (1<<5);
    GPIOF->DIR |= LED_1s;
    GPIOF->DEN |= LED_1s;

    // call the delay functions
    Timer1A_10sec_delay();
    Timer2A_5sec_delay();
    Timer3A_1sec_delay();

    while(1)
    {
        // infinite loop
    }
}

*****************************************
lab9:
#include "TM4C123.h" // Device header
#define LCD GPIOB //LCD port with Tiva C 
#define RS 0x01 //RS -> PB0 (0x01)
#define RW 0x02 //RW -> PB1 (0x02)
#define EN 0x04 //EN -> PB2 (0x04)
//Functions Declaration
void delayUs(int); //Delay in Micro Seconds
void delayMs(int); //Delay in Milli Seconds

void LCD4bits_Init(void); //Initialization of LCD Dispaly
void LCD_Write4bits(unsigned char, unsigned char); //Write data as (4 bits) on LCD
void LCD_WriteString(char*); //Write a string on LCD 
void LCD4bits_Cmd(unsigned char); //Write command 
void LCD4bits_Data(unsigned char); //Write a character
int main(void)
{
    char* name = "dana "; //Write your name here
    char* id = "1200081"; //Write your ID here
    LCD4bits_Init(); //Initialization of LCD
    LCD4bits_Cmd(0x01); //Clear the display
    LCD4bits_Cmd(0x80); //Force the cursor to beginning of 1st line
    delayMs(500); //delay 500ms for LCD (MCU is faster than LCD)
    LCD_WriteString(name); //Write the name on LCD
    delayMs(500); //Delay 500 ms to let the LCD diplays the data
    LCD4bits_Cmd(0xC0); //Force the cursor to beginning of 2nd line
    delayMs(500); //delay 500ms for LCD (MCU is faster than LCD)
    LCD_WriteString(id); //Write the ID on LCD
    delayMs(500); //Delay 500 ms to let the LCD diplays the data
}

void LCD4bits_Init(void)
{
SYSCTL->RCGCGPIO |= 0x02; //enable clock for PORTB
delayMs(10); //delay 10 ms for enable the clock of PORTB
 LCD->DIR = 0xFF; //let PORTB as output pins
LCD->DEN = 0xFF; //enable PORTB digital IO pins
LCD4bits_Cmd(0x28); //2 lines and 5x7 character (4-bit data, D4 to D7)
LCD4bits_Cmd(0x06); //Automatic Increment cursor (shift cursor to right)
LCD4bits_Cmd(0x01); //Clear display screen
LCD4bits_Cmd(0x0F); //Display on, cursor blinking
}
void LCD_Write4bits(unsigned char data, unsigned char control)
{
data &= 0xF0; //clear lower nibble for control 
control &= 0x0F; //clear upper nibble for data
LCD->DATA = data | control; //Include RS value (command or data ) with data 
LCD->DATA = data | control | EN; //pulse EN
delayUs(0); //delay for pulsing EN
LCD->DATA = data | control; //Turn off the pulse EN
LCD->DATA = 0; //Clear the Data 
}

void LCD_WriteString(char * str)
{ 
volatile int i = 0; //volatile is important 
while(*(str+i) != '\0') //until the end of the string
{
LCD4bits_Data(*(str+i)); //Write each character of string
i++; //increment for next character
}
}
void LCD4bits_Cmd(unsigned char command)
{
LCD_Write4bits(command & 0xF0 , 0); //upper nibble first
LCD_Write4bits(command << 4 , 0); //then lower nibble
if(command < 4)
delayMs(2); //commands 1 and 2 need up to 1.64ms
else
delayUs(40); //all others 40 us
}
void LCD4bits_Data(unsigned char data)
{
LCD_Write4bits(data & 0xF0 , RS); //upper nibble first
LCD_Write4bits(data << 4 , RS); //then lower nibble
delayUs(40); //delay for LCD (MCU is faster than LCD)
}
void delayMs(int n)
{ 
volatile int i,j; //volatile is important for variables incremented in code
for(i=0;i<n;i++)
for(j=0;j<3180;j++) //delay for 1 msec
{}
}
void delayUs(int n) 
{
volatile int i,j; //volatile is important for variables incremented in code
for(i=0;i<n;i++)
for(j=0;j<3;j++) //delay for 1 micro second
{}
}
-------------------------------
#include "TM4C123.h" // Device header
#define LCD GPIOB //LCD port with Tiva C 
#define RS 0x01 //RS -> PB0 (0x01)
#define RW 0x02 //RW -> PB1 (0x02)
#define EN 0x04 //EN -> PB2 (0x04)
//Functions Declaration
void delayUs(int); //Delay in Micro Seconds
void delayMs(int); //Delay in Milli Seconds

void LCD4bits_Init(void); //Initialization of LCD Dispaly
void LCD_Write4bits(unsigned char, unsigned char); //Write data as (4 bits) on LCD
void LCD_WriteString(char*); //Write a string on LCD 
void LCD4bits_Cmd(unsigned char); //Write command 
void LCD4bits_Data(unsigned char); //Write a character
int main(void)
{
	int count = 0x80;
    char* name = "dana "; //Write your name here
    char* id = "1200081"; //Write your ID here
    LCD4bits_Init(); //Initialization of LCD
   
    LCD4bits_Cmd(0x80); //Force the cursor to beginning of 1st line
	for(count=0x80;count<0x8F;count++){
		 LCD4bits_Cmd(count);
		    LCD_WriteString(name); //Write the name on LCD
		    delayMs(500); //Delay 500 ms to let the LCD diplays the data	
		LCD4bits_Cmd(0x01); //Clear the display

	}
    delayMs(500); //delay 500ms for LCD (MCU is faster than LCD)
    //LCD4bits_Cmd(0xC0); //Force the cursor to beginning of 2nd line
    //delayMs(500); //delay 500ms for LCD (MCU is faster than LCD)
   // LCD_WriteString(id); //Write the ID on LCD
    //delayMs(500); //Delay 500 ms to let the LCD diplays the data
}

void LCD4bits_Init(void)
{
SYSCTL->RCGCGPIO |= 0x02; //enable clock for PORTB
delayMs(10); //delay 10 ms for enable the clock of PORTB
 LCD->DIR = 0xFF; //let PORTB as output pins
LCD->DEN = 0xFF; //enable PORTB digital IO pins
LCD4bits_Cmd(0x28); //2 lines and 5x7 character (4-bit data, D4 to D7)
LCD4bits_Cmd(0x06); //Automatic Increment cursor (shift cursor to right)
LCD4bits_Cmd(0x01); //Clear display screen
LCD4bits_Cmd(0x0F); //Display on, cursor blinking
}
void LCD_Write4bits(unsigned char data, unsigned char control)
{
data &= 0xF0; //clear lower nibble for control 
control &= 0x0F; //clear upper nibble for data
LCD->DATA = data | control; //Include RS value (command or data ) with data 
LCD->DATA = data | control | EN; //pulse EN
delayUs(0); //delay for pulsing EN
LCD->DATA = data | control; //Turn off the pulse EN
LCD->DATA = 0; //Clear the Data 
}

void LCD_WriteString(char * str)
{ 
volatile int i = 0; //volatile is important 
while(*(str+i) != '\0') //until the end of the string
{
LCD4bits_Data(*(str+i)); //Write each character of string
i++; //increment for next character
}
}
void LCD4bits_Cmd(unsigned char command)
{
LCD_Write4bits(command & 0xF0 , 0); //upper nibble first
LCD_Write4bits(command << 4 , 0); //then lower nibble
if(command < 4)
delayMs(2); //commands 1 and 2 need up to 1.64ms
else
delayUs(40); //all others 40 us
}
void LCD4bits_Data(unsigned char data)
{
LCD_Write4bits(data & 0xF0 , RS); //upper nibble first
LCD_Write4bits(data << 4 , RS); //then lower nibble
delayUs(40); //delay for LCD (MCU is faster than LCD)
}
void delayMs(int n)
{ 
volatile int i,j; //volatile is important for variables incremented in code
for(i=0;i<n;i++)
for(j=0;j<3180;j++) //delay for 1 msec
{}
}
void delayUs(int n) 
{
volatile int i,j; //volatile is important for variables incremented in code
for(i=0;i<n;i++)
for(j=0;j<3;j++) //delay for 1 micro second
{}
}
******************************************************
lab10:
1:
/* TM4C123G Tiva C Series ADC Example */
/* This Program controls the onboard green LED based on discrete digital value of ADC */
/* If AN0 channel value is less 2048 digital value than LED turns off and otherwise remain on */
#include "TM4C123GH6PM.h"
#include <stdio.h>
//Functions Declaration
void delayUs(int); //Delay in Micro Seconds
volatile unsigned int adc_value;
void ADC0SS3_Handler(void){
adc_value = ADC0->SSFIFO3; /* read adc coversion result from SS3 FIFO*/
ADC0->ISC = 8; /* clear coversion clear flag bit*/
 ADC0->PSSI |= (1<<3); /* Enable SS3 conversion or start sampling data from AN0 */
}
int main(void)
{
char* str = "Tiva C starting"; //Write any string you want to display on LCD
char s[20];
volatile float voltage;
 /* Enable Clock to ADC0 and GPIO pins*/
 SYSCTL->RCGCGPIO |= (1<<4); /* Enable Clock to GPIOE or PE3/AN0 */
 SYSCTL->RCGCADC |= (1<<0); /* AD0 clock enable*/
 
 /* initialize PE3 for AIN0 input */
 GPIOE->AFSEL |= (1<<3); /* enable alternate function */
 GPIOE->DEN &= ~(1<<3); /* disable digital function */
 GPIOE->AMSEL |= (1<<3); /* enable analog function */
 
 /* initialize sample sequencer3 */
 ADC0->ACTSS &= ~(1<<3); /* disable SS3 during configuration */
 ADC0->EMUX &= ~0xF000; /* software trigger conversion */
 ADC0->SSMUX3 = 0; /* get input from channel 0 */
 ADC0->SSCTL3 |= (1<<1)|(1<<2); /* take one sample at a time, set flag at 1st sample */
 ADC0->ACTSS |= (1<<3); /* enable ADC0 sequencer 3 */
 
 /*Iniitialize PF3 as a digital output pin */
 
 SYSCTL->RCGCGPIO |= 0x20; // turn on bus clock for GPIOF
 GPIOF->DIR |= 0x08; //set GREEN pin as a digital output pin
 GPIOF->DEN |= 0x08;
 GPIOF->DIR |= 0x02; //set GREEN pin as a digital output pin
 GPIOF->DEN |= 0x02;
 // Enable PF3 pin as a digital pin
 /* Enable ADC Interrupt */
 ADC0->IM |= (1<<3); /* Unmask ADC0 sequence 3 interrupt*/
 NVIC->ISER[0] |= 0x00020000; /* enable IRQ17 for ADC0SS3*/
 ADC0->ACTSS |= (1<<3); /* enable ADC0 sequencer 3 */
 ADC0->PSSI |= (1<<3); /* Enable SS3 conversion or start sampling data from AN0 */
 while(1)
 {
/*control Green PF3->LED */
 /* convert digital value back into voltage */
 voltage = (adc_value * 0.0008);
 // sprintf(s, "\r\nVoltage = %f", voltage);
 if(adc_value >= 1000)
 GPIOF->DATA = 0x02; /* turn on green LED*/
 else if(adc_value < 1000)
 GPIOF->DATA = 0x08; /* turn off green LED*/
 }
}